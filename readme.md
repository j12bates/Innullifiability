# Innullifiability
This project is an attempt to learn more about a very specific mathsy-
feeling problem I came across playing an arithmetic game with a friend.
I'm not sure if it really has much to do with maths, and it could very
well be thoroughly in the 'computing' side of things. But I'm trying to
find a bunch of solutions, essentially, and try and find patterns and
interesting things.

Here's the problem written out very concisely: Find a set of positive
integers from which it is impossible to construct an arithmetic
expression, using each value only once, that evaluates to zero. Here, an
arithmetic expression can utilize bracketing, addition, subtraction,
multiplication, and division in the case where no remainder is
generated. Such a set is 'innullifiable'. If, on the other hand, it is
possible to construct a null-evaluating expression, a set is
'nullifiable'.

todo: examples of above

## Basic Logic
Through some basic reasoning, we can know that a set is nullifiable if
and only if there exist two non-overlapping expressions evaluating to
the same number: since we're using positive integers, the only way to
have zero be the result of a computation is to subtract a value from
itself, and once you get zero anywhere, you simply multiply by the
remaining values to nullify the set. With this simplified test for
nullifiability, we can easily say any set that contains the same value
twice is nullifiable, so we'll only look at sets without repetition. We
also know that any superset of a nullifiable set is also nullifiable.

This program is for finding all the innullifiable sets in a given search
space. Running an exhaustive test for every set in a search space would
be quite costly, so the approach actually used here is to generate new
nullifiable sets from smaller ones. There are two 'expansion phases' for
generating new sets from already-computed smaller ones: making
supersets, and introducing 'mutations' to the values. These mutations
essentially replace values with pairs of different values, from which a
simple expression evaluating to the original value can be made, thus
creating a completely new set that is still nullifiable. Importantly,
these mutations need not be introduced to sets generated through a
superset phase, as for those the original set would've undergone all
those same mutations too, making additional ones redundant.

todo: examples of above

todo: bit about how this doesn't cover everything

## Workflow
todo: synopsis? maybe just some command examples... idk

### Set Records
Set Records are the actual containers that hold information about sets.
They also define the search space to be used by programs. They hold a
status for each set, which can be 'marked', signifying the set is
nullifiable. It can also indicate whether a set was generated by
superset, and thus wouldn't need to undergo mutation.

A Record is configured with set size--the number of values in each set,
and M-Value Range--the range of the greatest set values, inclusive. Sets
are represented as values in ascending order (no repeated values), and
the record is itself sorted by set values, greater ones taking
precedence[^1].

For example, you might have a record with size 4 and M-Value ranging
from 11 to 16. The record would store information about sets starting at
$`{1, 2, 3, 11}`$ and ending at $`{13, 14, 15, 16}`$. The order would be
as follows:

0. $`{1, 2, 3, 11}`$
1. $`{1, 2, 4, 11}`$
2. $`{1, 3, 4, 11}`$
3. $`{2, 3, 4, 11}`$
4. $`{1, 2, 5, 11}`$
5. $`{1, 3, 5, 11}`$
...
1607. $`{11, 14, 15, 16}`$
1608. $`{12, 14, 15, 16}`$
1609. $`{13, 14, 15, 16}`$

[^1]: See ['Combinatorial Number System'](https://en.wikipedia.org/wiki/
Combinatorial_Number_System) on the English Wikipedia

### Programs
There are four programs. Each program works on a record at least, and so
must take in the record's set size and the filename to import from.

#### `gen`, Produce New Generation
This program implements the actual nullifiable set generation algorithm
described earlier, with the two expansion phases: supersets and
mutations. It takes in two records, a source and a destination, the
destination's set size being one greater than the source. The set size
provided should match the source record. It can run in a multithreaded
mode.

By default, the destination is loaded in, both expansion phases are run,
and the destination is exported back out. Expansion phases are optional
and it can be specified that only one should run with command-line
options `s` and `m`. Destination import can be skipped with option `c`,
in which case the destination is created with the same M-value range as
the source.

#### `weed`, Exhaustively Test Unmarked Sets
This program 'weeds out' any remaining nullifiable sets in a given set
record, by applying the exhaustive test to every unmarked set and
marking the fails. It can run in a multithreaded mode.

#### `eval`, Evaluate Record
This program will scan a record and print the representations of the
remaining unmarked sets, as well as the number of them. Alternately, a
short display of only the number of sets will be output if the `s`
option is passed.

#### `create`, Create Blank Record
This program will create a new record with everything unmarked. It must
be provided with the set size, as well as the min and max M-values, and
the filename.

### Scripts
todo: this
